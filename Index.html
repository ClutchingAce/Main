<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TypeMaster - Advanced Typing Test</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary-bg: #1a1a1a;
      --secondary-bg: #2d2d2d;
      --accent-bg: #3a3a3a;
      --text-primary: #ffffff;
      --text-secondary: #b3b3b3;
      --text-muted: #666666;
      --accent-color: #00d4ff;
      --success-color: #00ff88;
      --error-color: #ff4757;
      --warning-color: #ffa502;
      --border-color: #404040;
      --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      --border-radius: 12px;
      --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: linear-gradient(135deg, var(--primary-bg) 0%, #0f0f0f 100%);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      overflow-x: hidden;
    }

    .container {
      max-width: 1000px;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 30px;
    }

    .header {
      text-align: center;
      margin-bottom: 20px;
    }

    .header h1 {
      font-size: 3rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent-color), var(--success-color));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 10px;
      letter-spacing: -0.02em;
    }

    .header p {
      color: var(--text-secondary);
      font-size: 1.1rem;
      font-weight: 400;
    }

    .controls {
      background: var(--secondary-bg);
      border-radius: var(--border-radius);
      padding: 25px;
      box-shadow: var(--shadow);
      border: 1px solid var(--border-color);
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      align-items: end;
      justify-content: center;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 150px;
    }

    .control-group label {
      font-size: 0.9rem;
      font-weight: 500;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .control-group select,
    .control-group input {
      background: var(--accent-bg);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      padding: 12px 16px;
      color: var(--text-primary);
      font-size: 1rem;
      font-weight: 500;
      transition: var(--transition);
      outline: none;
    }

    .control-group select:focus,
    .control-group input:focus {
      border-color: var(--accent-color);
      box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.1);
    }

    .btn {
      background: linear-gradient(135deg, var(--accent-color), #0099cc);
      border: none;
      border-radius: 8px;
      padding: 14px 28px;
      color: white;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 212, 255, 0.4);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .stats-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--secondary-bg);
      border-radius: var(--border-radius);
      padding: 20px 25px;
      box-shadow: var(--shadow);
      border: 1px solid var(--border-color);
      flex-wrap: wrap;
      gap: 15px;
    }

    .stat {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }

    .stat-value {
      font-size: 1.8rem;
      font-weight: 700;
      color: var(--accent-color);
    }

    .stat-label {
      font-size: 0.8rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .progress-bar {
      width: 100%;
      height: 6px;
      background: var(--accent-bg);
      border-radius: 3px;
      overflow: hidden;
      margin: 10px 0;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent-color), var(--success-color));
      border-radius: 3px;
      transition: width 0.3s ease;
      width: 0%;
    }

    .test-container {
      background: var(--secondary-bg);
      border-radius: var(--border-radius);
      padding: 30px;
      box-shadow: var(--shadow);
      border: 1px solid var(--border-color);
      position: relative;
      overflow: hidden;
    }

    .test-header {
      display: flex;
      justify-content: flex-end;
      margin-bottom: 10px;
    }

    .quick-restart-btn {
      background: transparent;
      border: 1px solid var(--border-color);
      border-radius: 50%;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-secondary);
      font-size: 14px;
      cursor: pointer;
      transition: var(--transition);
      opacity: 0.6;
    }

    .quick-restart-btn:hover {
      background: var(--accent-bg);
      border-color: var(--accent-color);
      color: var(--accent-color);
      opacity: 1;
      transform: rotate(180deg);
    }

    .quick-restart-btn:active {
      transform: rotate(180deg) scale(0.95);
    }

    .test-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, var(--accent-color), var(--success-color));
    }

    #test {
      font-size: 1.5rem;
      line-height: 2.2;
      font-weight: 400;
      letter-spacing: 0.5px;
      max-height: 200px;
      overflow: hidden;
      position: relative;
      padding: 20px 0;
    }

    .line {
      display: flex;
      flex-wrap: wrap;
      margin-bottom: 15px;
      min-height: 2.2em;
      gap: 15px;
    }

    .word {
      white-space: nowrap;
      position: relative;
      flex-shrink: 0;
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .char {
      position: relative;
      transition: var(--transition);
    }

    .char.correct {
      color: var(--success-color);
      background: rgba(0, 255, 136, 0.1);
      border-radius: 3px;
      padding: 2px 1px;
    }

    .char.incorrect {
      color: var(--error-color);
      background: rgba(255, 71, 87, 0.1);
      border-radius: 3px;
      padding: 2px 1px;
      text-decoration: underline;
      text-decoration-color: var(--error-color);
    }

    .char.current {
      background: rgba(0, 212, 255, 0.2);
      border-radius: 3px;
      padding: 2px 1px;
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .word.current {
      background: rgba(0, 212, 255, 0.05);
      border-radius: 6px;
      padding: 2px 6px;
    }

    #input {
      width: 100%;
      font-size: 1.5rem;
      padding: 20px 25px;
      background: var(--accent-bg);
      border: 2px solid var(--border-color);
      border-radius: var(--border-radius);
      color: var(--text-primary);
      font-weight: 400;
      letter-spacing: 0.5px;
      transition: var(--transition);
      outline: none;
      margin-top: 25px;
    }

    #input:focus {
      border-color: var(--accent-color);
      box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.1);
    }

    #input:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .results {
      background: var(--secondary-bg);
      border-radius: var(--border-radius);
      padding: 30px;
      box-shadow: var(--shadow);
      border: 1px solid var(--border-color);
      text-align: center;
      display: none;
    }

    .results.show {
      display: block;
      animation: slideIn 0.5s ease-out;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .results h3 {
      font-size: 1.8rem;
      margin-bottom: 20px;
      color: var(--accent-color);
    }

    .results-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 20px;
      margin-bottom: 25px;
    }

    .result-item {
      background: var(--accent-bg);
      border-radius: 8px;
      padding: 20px;
      border: 1px solid var(--border-color);
    }

    .result-value {
      font-size: 2rem;
      font-weight: 700;
      color: var(--success-color);
      margin-bottom: 5px;
    }

    .result-label {
      font-size: 0.9rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .restart-btn {
      background: linear-gradient(135deg, var(--success-color), #00cc66);
      box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
    }

    .restart-btn:hover {
      box-shadow: 0 6px 20px rgba(0, 255, 136, 0.4);
    }

    .timer {
      font-size: 1.2rem;
      font-weight: 600;
      color: var(--warning-color);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .timer.warning {
      color: var(--error-color);
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.5; }
    }

    .error-message {
      background: rgba(255, 71, 87, 0.1);
      border: 1px solid var(--error-color);
      border-radius: 8px;
      padding: 15px;
      color: var(--error-color);
      margin: 15px 0;
      display: none;
    }

    .error-message.show {
      display: block;
      animation: slideIn 0.3s ease-out;
    }

    /* Achievement Notification */
    .achievement-notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: linear-gradient(135deg, var(--success-color), #00cc66);
      border-radius: var(--border-radius);
      padding: 20px;
      box-shadow: var(--shadow);
      transform: translateX(400px);
      transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1000;
      max-width: 300px;
    }

    .achievement-notification.show {
      transform: translateX(0);
    }

    .achievement-content {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .achievement-icon {
      font-size: 2rem;
    }

    .achievement-title {
      font-weight: 700;
      color: white;
      margin-bottom: 5px;
    }

    .achievement-description {
      color: rgba(255, 255, 255, 0.9);
      font-size: 0.9rem;
    }

    /* Custom Text Container */
    .custom-text-container {
      background: var(--secondary-bg);
      border-radius: var(--border-radius);
      padding: 25px;
      box-shadow: var(--shadow);
      border: 1px solid var(--border-color);
      margin-bottom: 20px;
    }

    .custom-text-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .custom-text-header h3 {
      color: var(--accent-color);
      margin: 0;
    }

    #customTextInput {
      width: 100%;
      min-height: 150px;
      background: var(--accent-bg);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      padding: 15px;
      color: var(--text-primary);
      font-size: 1rem;
      font-family: inherit;
      resize: vertical;
      margin-bottom: 15px;
    }

    #customTextInput:focus {
      border-color: var(--accent-color);
      box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.1);
      outline: none;
    }

    /* Results Actions */
    .results-actions {
      display: flex;
      gap: 15px;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 20px;
    }

    /* Modal Styles */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }

    .modal.show {
      display: flex;
    }

    .modal-content {
      background: var(--secondary-bg);
      border-radius: var(--border-radius);
      padding: 30px;
      box-shadow: var(--shadow);
      border: 1px solid var(--border-color);
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 15px;
    }

    .modal-header h3 {
      color: var(--accent-color);
      margin: 0;
    }

    /* Leaderboard Styles */
    .leaderboard-entry {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      background: var(--accent-bg);
      border-radius: 8px;
      margin-bottom: 10px;
      border: 1px solid var(--border-color);
    }

    .leaderboard-rank {
      font-weight: 700;
      color: var(--accent-color);
      font-size: 1.2rem;
    }

    .leaderboard-details {
      flex: 1;
      margin-left: 15px;
    }

    .leaderboard-wpm {
      font-weight: 600;
      color: var(--success-color);
    }

    .leaderboard-date {
      font-size: 0.8rem;
      color: var(--text-secondary);
    }

    /* Achievement Styles */
    .achievement-item {
      display: flex;
      align-items: center;
      padding: 15px;
      background: var(--accent-bg);
      border-radius: 8px;
      margin-bottom: 10px;
      border: 1px solid var(--border-color);
      transition: var(--transition);
    }

    .achievement-item.unlocked {
      border-color: var(--success-color);
      background: rgba(0, 255, 136, 0.1);
    }

    .achievement-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    .achievement-badge {
      font-size: 2rem;
      margin-right: 15px;
    }

    .achievement-info h4 {
      margin: 0 0 5px 0;
      color: var(--text-primary);
    }

    .achievement-info p {
      margin: 0;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .achievement-progress {
      margin-top: 5px;
      width: 100%;
      height: 4px;
      background: var(--border-color);
      border-radius: 2px;
      overflow: hidden;
    }

    .achievement-progress-fill {
      height: 100%;
      background: var(--accent-color);
      transition: width 0.3s ease;
    }

    /* Theme Variables */
    .theme-light {
      --primary-bg: #ffffff;
      --secondary-bg: #f8f9fa;
      --accent-bg: #e9ecef;
      --text-primary: #212529;
      --text-secondary: #6c757d;
      --text-muted: #adb5bd;
      --accent-color: #007bff;
      --success-color: #28a745;
      --error-color: #dc3545;
      --warning-color: #ffc107;
      --border-color: #dee2e6;
    }

    .theme-neon {
      --primary-bg: #0a0a0a;
      --secondary-bg: #1a1a1a;
      --accent-bg: #2a2a2a;
      --text-primary: #00ff41;
      --text-secondary: #00cc33;
      --text-muted: #009926;
      --accent-color: #ff00ff;
      --success-color: #00ff41;
      --error-color: #ff0040;
      --warning-color: #ffff00;
      --border-color: #333333;
    }

    .theme-retro {
      --primary-bg: #2c1810;
      --secondary-bg: #3d2817;
      --accent-bg: #4d331f;
      --text-primary: #f4e4bc;
      --text-secondary: #d4c4a4;
      --text-muted: #b4a484;
      --accent-color: #ff6b35;
      --success-color: #4ecdc4;
      --error-color: #ff4757;
      --warning-color: #ffa502;
      --border-color: #5d4427;
    }

    .theme-ocean {
      --primary-bg: #0c1445;
      --secondary-bg: #1a237e;
      --accent-bg: #283593;
      --text-primary: #e3f2fd;
      --text-secondary: #bbdefb;
      --text-muted: #90caf9;
      --accent-color: #00bcd4;
      --success-color: #4caf50;
      --error-color: #f44336;
      --warning-color: #ff9800;
      --border-color: #3949ab;
    }

    .theme-forest {
      --primary-bg: #1b2e1b;
      --secondary-bg: #2d4a2d;
      --accent-bg: #3d5a3d;
      --text-primary: #e8f5e8;
      --text-secondary: #c8e6c8;
      --text-muted: #a8d8a8;
      --accent-color: #4caf50;
      --success-color: #8bc34a;
      --error-color: #f44336;
      --warning-color: #ffc107;
      --border-color: #4a6741;
    }

    /* Particle Effects */
    .particle {
      position: absolute;
      pointer-events: none;
      border-radius: 50%;
      animation: particle-float 1s ease-out forwards;
    }

    @keyframes particle-float {
      0% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
      100% {
        opacity: 0;
        transform: translateY(-50px) scale(0.5);
      }
    }

    /* Screen Shake Animation */
    .screen-shake {
      animation: shake 0.3s ease-in-out;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }


    @media (max-width: 768px) {
      .container {
        padding: 10px;
        gap: 20px;
      }

      .header h1 {
        font-size: 2rem;
      }

      .controls {
        flex-direction: column;
        align-items: stretch;
      }

      .control-group {
        min-width: auto;
      }

      .stats-bar {
        flex-direction: column;
        gap: 20px;
      }

      #test {
        font-size: 1.2rem;
        line-height: 2;
      }

      #input {
        font-size: 1.2rem;
        padding: 15px 20px;
      }

      .results-grid {
        grid-template-columns: repeat(2, 1fr);
      }

      .results-actions {
        flex-direction: column;
        align-items: center;
      }

      .achievement-notification {
        right: 10px;
        left: 10px;
        max-width: none;
      }

      .modal-content {
        width: 95%;
        padding: 20px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>TypeMaster</h1>
      <p>Test your typing speed and accuracy with our advanced typing test</p>
    </div>


    <div class="controls">
      <div class="control-group">
        <label>Test Mode</label>
        <select id="mode">
          <option value="words">Words (25 words)</option>
          <option value="time">Time (30 seconds)</option>
          <option value="time60">Time (60 seconds)</option>
          <option value="time120">Time (120 seconds)</option>
          <option value="quotes">Quote Mode</option>
          <option value="code">Code Mode</option>
          <option value="random">Random Characters</option>
          <option value="custom">Custom Text</option>
        </select>
      </div>
      
      <div class="control-group">
        <label>Difficulty</label>
        <select id="difficulty">
          <option value="easy">Easy</option>
          <option value="medium" selected>Medium</option>
          <option value="hard">Hard</option>
        </select>
      </div>

      <div class="control-group">
        <label>Theme</label>
        <select id="theme">
          <option value="dark" selected>Dark</option>
          <option value="light">Light</option>
          <option value="neon">Neon</option>
          <option value="retro">Retro</option>
          <option value="ocean">Ocean</option>
          <option value="forest">Forest</option>
        </select>
      </div>

      <div class="control-group">
        <label>Sound</label>
        <button id="soundToggle" class="btn" style="padding: 12px 16px; font-size: 0.9rem;">üîä On</button>
      </div>

      <button id="startBtn" class="btn">Start Test</button>
    </div>

    <div class="stats-bar">
      <div class="stat">
        <div class="stat-value" id="wpmDisplay">0</div>
        <div class="stat-label">WPM</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="accuracyDisplay">0%</div>
        <div class="stat-label">Accuracy</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="progressDisplay">0%</div>
        <div class="stat-label">Progress</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="timerDisplay">--</div>
        <div class="stat-label">Time</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="streakDisplay">0</div>
        <div class="stat-label">Streak</div>
      </div>
    </div>

    <div class="progress-bar">
      <div class="progress-fill" id="progressBar"></div>
    </div>

    <div class="test-container">
      <div class="test-header">
        <button id="quickRestartBtn" class="quick-restart-btn" title="Restart Test">‚Üª</button>
      </div>
      <div id="test"></div>
      <input id="input" type="text" disabled placeholder="Click 'Start Test' to begin typing..." />
    </div>

    <div class="error-message" id="errorMessage"></div>

    <!-- Achievement Notification -->
    <div class="achievement-notification" id="achievementNotification">
      <div class="achievement-content">
        <div class="achievement-icon">üèÜ</div>
        <div class="achievement-text">
          <div class="achievement-title">Achievement Unlocked!</div>
          <div class="achievement-description"></div>
        </div>
      </div>
    </div>

    <!-- Custom Text Input -->
    <div class="custom-text-container" id="customTextContainer" style="display: none;">
      <div class="custom-text-header">
        <h3>Custom Text Practice</h3>
        <button id="closeCustomText" class="btn" style="padding: 8px 12px; font-size: 0.8rem;">‚úï</button>
      </div>
      <textarea id="customTextInput" placeholder="Paste your text here to practice typing..."></textarea>
      <button id="useCustomText" class="btn">Use This Text</button>
    </div>

    <div class="results" id="results">
      <h3>Test Complete!</h3>
      <div class="results-grid">
        <div class="result-item">
          <div class="result-value" id="finalWPM">0</div>
          <div class="result-label">Words Per Minute</div>
        </div>
        <div class="result-item">
          <div class="result-value" id="finalAccuracy">0%</div>
          <div class="result-label">Accuracy</div>
        </div>
        <div class="result-item">
          <div class="result-value" id="finalChars">0</div>
          <div class="result-label">Characters</div>
        </div>
        <div class="result-item">
          <div class="result-value" id="finalErrors">0</div>
          <div class="result-label">Errors</div>
        </div>
      </div>
      <div class="results-actions">
      <button id="restartBtn" class="btn restart-btn">Try Again</button>
        <button id="customTextBtn" class="btn">Custom Text</button>
        <button id="leaderboardBtn" class="btn">Leaderboard</button>
        <button id="achievementsBtn" class="btn">Achievements</button>
      </div>
    </div>

    <!-- Leaderboard Modal -->
    <div class="modal" id="leaderboardModal">
      <div class="modal-content">
        <div class="modal-header">
          <h3>Personal Best Scores</h3>
          <button id="closeLeaderboard" class="btn" style="padding: 8px 12px; font-size: 0.8rem;">‚úï</button>
        </div>
        <div class="leaderboard-content" id="leaderboardContent">
          <!-- Leaderboard entries will be populated here -->
        </div>
      </div>
    </div>

    <!-- Achievements Modal -->
    <div class="modal" id="achievementsModal">
      <div class="modal-content">
        <div class="modal-header">
          <h3>Achievements</h3>
          <button id="closeAchievements" class="btn" style="padding: 8px 12px; font-size: 0.8rem;">‚úï</button>
        </div>
        <div class="achievements-content" id="achievementsContent">
          <!-- Achievements will be populated here -->
        </div>
      </div>
    </div>
  </div>

  <script>
    // Enhanced word lists for different difficulties and special modes
    const wordLists = {
      easy: [
        "the", "and", "for", "are", "but", "not", "you", "all", "can", "had", "her", "was", "one", "our", "out", "day", "get", "has", "him", "his", "how", "its", "may", "new", "now", "old", "see", "two", "way", "who", "boy", "did", "man", "yes", "too", "any", "many", "some", "time", "very", "when", "come", "here", "just", "like", "long", "make", "much", "over", "such", "take", "than", "them", "well", "were"
      ],
      medium: [
        "hello", "world", "typing", "speed", "keyboard", "javascript", "practice", "coding", "developer", "random", "monkey", "test", "accuracy", "function", "simple", "project", "challenge", "style", "result", "finish", "future", "computer", "program", "language", "website", "application", "interface", "database", "algorithm", "framework", "library", "component", "variable", "constant", "method", "class", "object", "array", "string", "number", "boolean", "condition", "iteration", "recursion", "optimization", "performance", "security", "validation", "authentication", "authorization"
      ],
      hard: [
        "pneumonia", "xylophone", "rhythm", "symphony", "psychology", "philosophy", "archaeology", "entrepreneur", "bureaucracy", "connoisseur", "entrepreneurial", "incomprehensible", "unprecedented", "characteristics", "responsibilities", "representatives", "constitutional", "revolutionary", "extraordinary", "superintendent", "acknowledgment", "accomplishment", "establishment", "disappointment", "embarrassment", "misunderstanding", "overwhelming", "underestimated", "rehabilitation", "transformation", "implementation", "documentation", "specification", "configuration", "initialization", "authentication", "authorization", "optimization", "visualization", "categorization", "standardization", "personalization", "customization", "specialization", "generalization", "rationalization", "organization", "administration"
      ],
      quotes: [
        "The only way to do great work is to love what you do.",
        "Innovation distinguishes between a leader and a follower.",
        "Life is what happens to you while you're busy making other plans.",
        "The future belongs to those who believe in the beauty of their dreams.",
        "It is during our darkest moments that we must focus to see the light.",
        "Success is not final, failure is not fatal: it is the courage to continue that counts.",
        "The way to get started is to quit talking and begin doing.",
        "Don't be pushed around by the fears in your mind. Be led by the dreams in your heart.",
        "The only impossible journey is the one you never begin.",
        "In the middle of difficulty lies opportunity."
      ],
      code: [
        "function calculateSum(a, b) { return a + b; }",
        "const array = [1, 2, 3, 4, 5];",
        "if (condition) { console.log('Hello World'); }",
        "class MyClass { constructor() { this.value = 0; } }",
        "const result = array.map(x => x * 2);",
        "try { riskyOperation(); } catch (error) { handleError(error); }",
        "const promise = fetch('/api/data').then(response => response.json());",
        "import React from 'react'; export default function App() { return <div>Hello</div>; }",
        "const config = { apiUrl: 'https://api.example.com', timeout: 5000 };",
        "async function fetchData() { const response = await fetch('/api'); return response.json(); }"
      ],
      random: [
        "!@#$%^&*()_+-=[]{}|;':\",./<>?",
        "qwertyuiopasdfghjklzxcvbnm",
        "QWERTYUIOPASDFGHJKLZXCVBNM",
        "1234567890",
        "~`!@#$%^&*()_+-={}[]|\\:;\"'<>?,./",
        "abcdefghijklmnopqrstuvwxyz",
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        "0123456789",
        "!@#$%^&*()_+-=[]{}|;':\",./<>?",
        "qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM"
      ]
    };

    // Achievement system
    class AchievementSystem {
      constructor() {
        this.achievements = {
          firstTest: { id: 'firstTest', name: 'First Steps', description: 'Complete your first typing test', icon: 'üéØ', unlocked: false, progress: 0, target: 1 },
          speedDemon: { id: 'speedDemon', name: 'Speed Demon', description: 'Reach 100+ WPM', icon: '‚ö°', unlocked: false, progress: 0, target: 100 },
          perfectionist: { id: 'perfectionist', name: 'Perfectionist', description: 'Achieve 100% accuracy', icon: 'üéØ', unlocked: false, progress: 0, target: 100 },
          marathon: { id: 'marathon', name: 'Marathon Runner', description: 'Complete 10 tests', icon: 'üèÉ', unlocked: false, progress: 0, target: 10 },
          consistent: { id: 'consistent', name: 'Consistent', description: 'Maintain 90%+ accuracy for 5 tests', icon: 'üìà', unlocked: false, progress: 0, target: 5 },
          quickDraw: { id: 'quickDraw', name: 'Quick Draw', description: 'Reach 150+ WPM', icon: 'üî´', unlocked: false, progress: 0, target: 150 },
          master: { id: 'master', name: 'Typing Master', description: 'Reach 200+ WPM', icon: 'üëë', unlocked: false, progress: 0, target: 200 },
          dedicated: { id: 'dedicated', name: 'Dedicated', description: 'Complete 50 tests', icon: 'üí™', unlocked: false, progress: 0, target: 50 }
        };
        this.loadAchievements();
      }

      loadAchievements() {
        const saved = localStorage.getItem('typingGame_achievements');
        if (saved) {
          const savedAchievements = JSON.parse(saved);
          Object.keys(this.achievements).forEach(key => {
            if (savedAchievements[key]) {
              this.achievements[key] = { ...this.achievements[key], ...savedAchievements[key] };
            }
          });
        }
      }

      saveAchievements() {
        localStorage.setItem('typingGame_achievements', JSON.stringify(this.achievements));
      }

      checkAchievements(wpm, accuracy, testCount) {
        const newAchievements = [];
        
        // First test
        if (testCount >= 1 && !this.achievements.firstTest.unlocked) {
          this.achievements.firstTest.unlocked = true;
          newAchievements.push(this.achievements.firstTest);
        }

        // Speed achievements
        if (wpm >= 100 && !this.achievements.speedDemon.unlocked) {
          this.achievements.speedDemon.unlocked = true;
          newAchievements.push(this.achievements.speedDemon);
        }

        if (wpm >= 150 && !this.achievements.quickDraw.unlocked) {
          this.achievements.quickDraw.unlocked = true;
          newAchievements.push(this.achievements.quickDraw);
        }

        if (wpm >= 200 && !this.achievements.master.unlocked) {
          this.achievements.master.unlocked = true;
          newAchievements.push(this.achievements.master);
        }

        // Accuracy achievement
        if (accuracy >= 100 && !this.achievements.perfectionist.unlocked) {
          this.achievements.perfectionist.unlocked = true;
          newAchievements.push(this.achievements.perfectionist);
        }

        // Test count achievements
        if (testCount >= 10 && !this.achievements.marathon.unlocked) {
          this.achievements.marathon.unlocked = true;
          newAchievements.push(this.achievements.marathon);
        }

        if (testCount >= 50 && !this.achievements.dedicated.unlocked) {
          this.achievements.dedicated.unlocked = true;
          newAchievements.push(this.achievements.dedicated);
        }

        this.saveAchievements();
        return newAchievements;
      }

      showAchievement(achievement) {
        const notification = document.getElementById('achievementNotification');
        const title = notification.querySelector('.achievement-title');
        const description = notification.querySelector('.achievement-description');
        const icon = notification.querySelector('.achievement-icon');

        title.textContent = achievement.name;
        description.textContent = achievement.description;
        icon.textContent = achievement.icon;

        notification.classList.add('show');
        setTimeout(() => {
          notification.classList.remove('show');
        }, 3000);
      }
    }

    // Theme system
    class ThemeSystem {
      constructor() {
        this.currentTheme = localStorage.getItem('typingGame_theme') || 'dark';
        this.applyTheme(this.currentTheme);
      }

      applyTheme(themeName) {
        document.body.className = `theme-${themeName}`;
        this.currentTheme = themeName;
        localStorage.setItem('typingGame_theme', themeName);
      }

      getCurrentTheme() {
        return this.currentTheme;
      }
    }

    // Progress tracking system
    class ProgressSystem {
      constructor() {
        this.stats = {
          totalTests: 0,
          bestWPM: 0,
          bestAccuracy: 0,
          totalWords: 0,
          totalErrors: 0,
          streak: 0,
          lastTestDate: null,
          testHistory: []
        };
        this.loadStats();
      }

      loadStats() {
        const saved = localStorage.getItem('typingGame_stats');
        if (saved) {
          this.stats = { ...this.stats, ...JSON.parse(saved) };
        }
      }

      saveStats() {
        localStorage.setItem('typingGame_stats', JSON.stringify(this.stats));
      }

      updateStats(wpm, accuracy, words, errors) {
        this.stats.totalTests++;
        this.stats.bestWPM = Math.max(this.stats.bestWPM, wpm);
        this.stats.bestAccuracy = Math.max(this.stats.bestAccuracy, accuracy);
        this.stats.totalWords += words;
        this.stats.totalErrors += errors;

        // Update streak
        const today = new Date().toDateString();
        if (this.stats.lastTestDate !== today) {
          const yesterday = new Date();
          yesterday.setDate(yesterday.getDate() - 1);
          if (this.stats.lastTestDate === yesterday.toDateString()) {
            this.stats.streak++;
          } else if (this.stats.lastTestDate !== today) {
            this.stats.streak = 1;
          }
          this.stats.lastTestDate = today;
        }

        // Add to history
        this.stats.testHistory.push({
          date: today,
          wpm: wpm,
          accuracy: accuracy,
          words: words,
          errors: errors
        });

        // Keep only last 100 tests
        if (this.stats.testHistory.length > 100) {
          this.stats.testHistory = this.stats.testHistory.slice(-100);
        }

        this.saveStats();
      }

      getStats() {
        return this.stats;
      }
    }


    // Audio system for typing sounds
    class AudioSystem {
      constructor() {
        this.audioContext = null;
        this.soundsEnabled = true;
        this.initAudio();
      }

      initAudio() {
        try {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
          console.log('Web Audio API not supported');
          this.soundsEnabled = false;
        }
      }

      playTypingSound(type = 'key') {
        if (!this.soundsEnabled || !this.audioContext) return;

        // Simple, gentle click sound
        const now = this.audioContext.currentTime;
        
        // Create a simple oscillator for a gentle click
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        // Connect the audio graph
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);

        // Simple sound configuration - gentle click
        const config = {
          freq: 800,  // Lower frequency for gentler sound
          duration: 0.05,  // Very short duration
          volume: 0.03  // Much quieter volume
        };
        
        // Set frequency
        oscillator.frequency.setValueAtTime(config.freq, now);
        
        // Use sine wave for the softest sound
        oscillator.type = 'sine';
        
        // Create a quick envelope for a click sound
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(config.volume, now + 0.001);
        gainNode.gain.exponentialRampToValueAtTime(0.001, now + config.duration);
        
        // Start and stop oscillator
        oscillator.start(now);
        oscillator.stop(now + config.duration);
      }

      toggleSounds() {
        this.soundsEnabled = !this.soundsEnabled;
        return this.soundsEnabled;
      }
    }

    // Game state
    class TypingGame {
      constructor() {
        this.lines = [];
        this.currentLine = 0;
        this.currentWord = 0;
        this.currentChar = 0;
        this.correctChars = 0;
        this.totalChars = 0;
        this.errors = 0;
        this.startTime = null;
        this.timerInterval = null;
        this.updateInterval = null;
        this.mode = "words";
        this.difficulty = "medium";
        this.isActive = false;
        this.targetWords = 25;
        this.targetTime = 30;
        this.audioSystem = new AudioSystem();
        this.achievementSystem = new AchievementSystem();
        this.themeSystem = new ThemeSystem();
        this.progressSystem = new ProgressSystem();
        this.customText = null;
        
        this.initializeElements();
        this.bindEvents();
        this.updateStreakDisplay();
      }

      initializeElements() {
        this.testDiv = document.getElementById("test");
        this.input = document.getElementById("input");
        this.results = document.getElementById("results");
        this.modeSelect = document.getElementById("mode");
        this.difficultySelect = document.getElementById("difficulty");
        this.themeSelect = document.getElementById("theme");
        this.startBtn = document.getElementById("startBtn");
        this.restartBtn = document.getElementById("restartBtn");
        this.errorMessage = document.getElementById("errorMessage");
        this.soundToggle = document.getElementById("soundToggle");
        
        // Stats displays
        this.wpmDisplay = document.getElementById("wpmDisplay");
        this.accuracyDisplay = document.getElementById("accuracyDisplay");
        this.progressDisplay = document.getElementById("progressDisplay");
        this.timerDisplay = document.getElementById("timerDisplay");
        this.streakDisplay = document.getElementById("streakDisplay");
        this.progressBar = document.getElementById("progressBar");
        
        // Final results
        this.finalWPM = document.getElementById("finalWPM");
        this.finalAccuracy = document.getElementById("finalAccuracy");
        this.finalChars = document.getElementById("finalChars");
        this.finalErrors = document.getElementById("finalErrors");
        
        // New elements
        this.quickRestartBtn = document.getElementById("quickRestartBtn");
        this.customTextContainer = document.getElementById("customTextContainer");
        this.customTextInput = document.getElementById("customTextInput");
        this.useCustomTextBtn = document.getElementById("useCustomText");
        this.closeCustomTextBtn = document.getElementById("closeCustomText");
        this.customTextBtn = document.getElementById("customTextBtn");
        this.leaderboardBtn = document.getElementById("leaderboardBtn");
        this.achievementsBtn = document.getElementById("achievementsBtn");
        this.leaderboardModal = document.getElementById("leaderboardModal");
        this.achievementsModal = document.getElementById("achievementsModal");
        this.closeLeaderboardBtn = document.getElementById("closeLeaderboard");
        this.closeAchievementsBtn = document.getElementById("closeAchievements");
        this.leaderboardContent = document.getElementById("leaderboardContent");
        this.achievementsContent = document.getElementById("achievementsContent");
        
        // Set current theme
        this.themeSelect.value = this.themeSystem.getCurrentTheme();
      }

      bindEvents() {
        this.startBtn.addEventListener("click", () => this.startTest());
        this.restartBtn.addEventListener("click", () => this.resetTest());
        this.quickRestartBtn.addEventListener("click", () => this.resetTest());
        this.soundToggle.addEventListener("click", () => this.toggleSound());
        this.themeSelect.addEventListener("change", (e) => this.themeSystem.applyTheme(e.target.value));
        this.input.addEventListener("input", (e) => this.handleInput(e));
        this.input.addEventListener("keydown", (e) => this.handleKeydown(e));
        
        // Custom text events
        this.customTextBtn.addEventListener("click", () => this.showCustomTextContainer());
        this.closeCustomTextBtn.addEventListener("click", () => this.hideCustomTextContainer());
        this.useCustomTextBtn.addEventListener("click", () => this.useCustomText());
        
        // Modal events
        this.leaderboardBtn.addEventListener("click", () => this.showLeaderboard());
        this.achievementsBtn.addEventListener("click", () => this.showAchievements());
        this.closeLeaderboardBtn.addEventListener("click", () => this.hideLeaderboard());
        this.closeAchievementsBtn.addEventListener("click", () => this.hideAchievements());
        
        // Close modals when clicking outside
        this.leaderboardModal.addEventListener("click", (e) => {
          if (e.target === this.leaderboardModal) this.hideLeaderboard();
        });
        this.achievementsModal.addEventListener("click", (e) => {
          if (e.target === this.achievementsModal) this.hideAchievements();
        });
        
        // Prevent backspace from going back in browser
        document.addEventListener("keydown", (e) => {
          if (e.key === "Backspace" && this.isActive) {
            e.preventDefault();
          }
        });
      }

      toggleSound() {
        const isEnabled = this.audioSystem.toggleSounds();
        this.soundToggle.textContent = isEnabled ? "üîä On" : "üîá Off";
        this.soundToggle.style.background = isEnabled 
          ? "linear-gradient(135deg, var(--accent-color), #0099cc)"
          : "linear-gradient(135deg, var(--text-muted), #555)";
      }

      resetTest() {
        this.testDiv.innerHTML = "";
        this.testDiv.scrollTop = 0; // Reset scroll position to top
        this.results.classList.remove("show");
        this.input.value = "";
        this.input.disabled = true;
        this.input.placeholder = "Click 'Start Test' to begin typing...";
        this.hideError();
        
        this.lines = [];
        this.currentLine = 0;
        this.currentWord = 0;
        this.currentChar = 0;
        this.correctChars = 0;
        this.totalChars = 0;
        this.errors = 0;
        this.startTime = null;
        this.isActive = false;
        
        if (this.timerInterval) clearInterval(this.timerInterval);
        if (this.updateInterval) clearInterval(this.updateInterval);
        
        this.updateStats();
        this.startBtn.disabled = false;
        this.startBtn.textContent = "Start Test";
      }

      startTest() {
        this.resetTest();
        this.mode = this.modeSelect.value;
        this.difficulty = this.difficultySelect.value;
        
        // Set target based on mode
        if (this.mode === "words") {
          this.targetWords = 25;
        } else if (this.mode === "time") {
          this.targetTime = 30;
        } else if (this.mode === "time60") {
          this.targetTime = 60;
        } else if (this.mode === "time120") {
          this.targetTime = 120;
        }
        
        this.generateText();
        this.input.disabled = false;
        this.input.focus();
        this.input.placeholder = "Start typing...";
        this.startBtn.disabled = true;
        this.startBtn.textContent = "Test Active";
        this.isActive = true;
        
        if (this.mode !== "words") {
          this.startTimer();
        }
        
        this.startStatsUpdate();
      }

      generateText() {
        let textToUse;
        
        if (this.mode === "custom" && this.customText) {
          textToUse = this.customText;
        } else if (this.mode === "quotes") {
          textToUse = wordLists.quotes[Math.floor(Math.random() * wordLists.quotes.length)];
        } else if (this.mode === "code") {
          textToUse = wordLists.code[Math.floor(Math.random() * wordLists.code.length)];
        } else if (this.mode === "random") {
          textToUse = wordLists.random[Math.floor(Math.random() * wordLists.random.length)];
        } else {
          // Regular word mode
        const words = wordLists[this.difficulty];
        const wordsPerLine = this.difficulty === 'hard' ? 5 : this.difficulty === 'medium' ? 6 : 8;
        let numLines;
        
        if (this.mode === "words") {
          numLines = Math.ceil(this.targetWords / wordsPerLine);
        } else {
          // Generate enough text for timed mode
          numLines = Math.max(10, Math.ceil(this.targetTime * 2));
        }
        
          const wordArray = [];
        for (let l = 0; l < numLines; l++) {
            for (let i = 0; i < wordsPerLine; i++) {
              wordArray.push(words[Math.floor(Math.random() * words.length)]);
            }
          }
          textToUse = wordArray.join(' ');
        }
        
        // Split text into words and create display
        const words = textToUse.split(' ');
        const wordsPerLine = this.mode === 'random' ? 10 : this.difficulty === 'hard' ? 5 : this.difficulty === 'medium' ? 6 : 8;
        
        for (let i = 0; i < words.length; i += wordsPerLine) {
          const line = document.createElement("div");
          line.className = "line";
          
          const lineWords = words.slice(i, i + wordsPerLine);
          lineWords.forEach(wordText => {
            const wordSpan = document.createElement("span");
            wordSpan.className = "word";
            
            [...wordText].forEach(ch => {
              const charSpan = document.createElement("span");
              charSpan.textContent = ch;
              charSpan.className = "char";
              wordSpan.appendChild(charSpan);
            });
            
            line.appendChild(wordSpan);
          });
          
          this.lines.push(line);
          this.testDiv.appendChild(line);
        }
        
        this.highlightCurrentWord();
      }

      highlightCurrentWord() {
        // Remove previous highlights
        document.querySelectorAll(".word.current").forEach(w => w.classList.remove("current"));
        document.querySelectorAll(".char.current").forEach(c => c.classList.remove("current"));
        
        if (this.currentLine < this.lines.length) {
          const line = this.lines[this.currentLine];
          const words = line.querySelectorAll(".word");
          
          if (this.currentWord < words.length) {
            words[this.currentWord].classList.add("current");
            
            const chars = words[this.currentWord].querySelectorAll(".char");
            if (this.currentChar < chars.length) {
              chars[this.currentChar].classList.add("current");
            }
          }
        }
      }

      handleInput(e) {
        if (!this.isActive) return;
        
        if (!this.startTime) {
          this.startTime = new Date();
        }
        
        const line = this.lines[this.currentLine];
        if (!line) return;
        
        const words = line.querySelectorAll(".word");
        if (this.currentWord >= words.length) return;
        
        const chars = words[this.currentWord].querySelectorAll(".char");
        const typed = this.input.value;
        
        // Reset character colors
        chars.forEach(c => c.classList.remove("correct", "incorrect"));
        
        // Check each typed character
        let hasError = false;
        let hasNewError = false;
        for (let i = 0; i < typed.length; i++) {
          if (i < chars.length) {
            if (typed[i] === chars[i].textContent) {
              chars[i].classList.add("correct");
            } else {
              chars[i].classList.add("incorrect");
              hasError = true;
              // Only play error sound for new errors (not on every keystroke)
              if (i === typed.length - 1) {
                hasNewError = true;
              }
            }
          }
        }
        
        // Play error sound only for new errors
        if (hasNewError) {
          this.audioSystem.playTypingSound('error');
          this.addScreenShake();
        }
        
        // Update current character position
        this.currentChar = Math.min(typed.length, chars.length);
        this.highlightCurrentWord();
        
        // Check if word is complete
        if (typed.endsWith(" ") && typed.trim().length > 0) {
          // Play space sound
          this.audioSystem.playTypingSound('space');
          this.processCompletedWord(words[this.currentWord], typed.trim());
        } else if (typed.length > 0 && !hasError) {
          // Play subtle typing sound occasionally (not on every keystroke)
          if (Math.random() < 0.3) { // 30% chance
            this.audioSystem.playTypingSound('key');
          }
          
          // Add particle effect for correct keystrokes occasionally
          if (Math.random() < 0.1) { // 10% chance
            const rect = this.input.getBoundingClientRect();
            this.createParticleEffect(rect.left + rect.width / 2, rect.top);
          }
        }
      }

      handleKeydown(e) {
        if (!this.isActive) return;
        
        // Handle backspace
        if (e.key === "Backspace") {
          e.preventDefault();
          const currentValue = this.input.value;
          if (currentValue.length > 0) {
            this.input.value = currentValue.slice(0, -1);
            this.handleInput(e);
          }
        }
        
        // Handle escape to reset
        if (e.key === "Escape") {
          this.resetTest();
        }
      }

      processCompletedWord(wordElement, typedWord) {
        const chars = wordElement.querySelectorAll(".char");
        const correctChars = wordElement.querySelectorAll(".char.correct").length;
        const incorrectChars = wordElement.querySelectorAll(".char.incorrect").length;
        
        this.totalChars += chars.length;
        this.correctChars += correctChars;
        this.errors += incorrectChars;
        
        // Move to next word
        this.input.value = "";
        this.currentWord++;
        this.currentChar = 0;
        
        // Check if line is complete
        if (this.currentWord >= this.lines[this.currentLine].querySelectorAll(".word").length) {
          this.currentLine++;
          this.currentWord = 0;
          this.scrollToCurrentLine();
        }
        
        this.highlightCurrentWord();
        this.updateStats();
        
        // Check if test is complete
        if (this.mode === "words") {
          const wordsPerLine = this.difficulty === 'hard' ? 5 : this.difficulty === 'medium' ? 6 : 8;
          const totalWordsTyped = this.currentLine * wordsPerLine + this.currentWord;
          if (totalWordsTyped >= this.targetWords) {
            this.endTest();
          }
        }
      }

      scrollToCurrentLine() {
        const lineHeight = 2.2; // em
        const scrollAmount = this.currentLine * lineHeight * 16; // Convert em to px
        this.testDiv.scrollTop = scrollAmount;
      }

      startTimer() {
        let timeLeft = this.targetTime;
        this.updateTimerDisplay(timeLeft);
        
        this.timerInterval = setInterval(() => {
          timeLeft--;
          this.updateTimerDisplay(timeLeft);
          
          if (timeLeft <= 0) {
            clearInterval(this.timerInterval);
            this.endTest();
          }
        }, 1000);
      }

      updateTimerDisplay(timeLeft) {
        const minutes = Math.floor(timeLeft / 60);
        const seconds = timeLeft % 60;
        this.timerDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        
        // Add warning class when time is low
        if (timeLeft <= 10) {
          this.timerDisplay.classList.add("warning");
        } else {
          this.timerDisplay.classList.remove("warning");
        }
      }

      startStatsUpdate() {
        this.updateInterval = setInterval(() => {
          this.updateStats();
        }, 100);
      }

      updateStats() {
        if (!this.startTime) return;
        
        const elapsed = (new Date() - this.startTime) / 1000 / 60; // minutes
        const wpm = elapsed > 0 ? Math.round((this.correctChars / 5) / elapsed) : 0;
        const accuracy = this.totalChars > 0 ? Math.round((this.correctChars / this.totalChars) * 100) : 0;
        
        // Calculate progress
        let progress = 0;
        if (this.mode === "words") {
          const wordsPerLine = this.difficulty === 'hard' ? 5 : this.difficulty === 'medium' ? 6 : 8;
          const totalWordsTyped = this.currentLine * wordsPerLine + this.currentWord;
          progress = Math.min(100, Math.round((totalWordsTyped / this.targetWords) * 100));
        } else {
          const elapsedSeconds = (new Date() - this.startTime) / 1000;
          progress = Math.min(100, Math.round((elapsedSeconds / this.targetTime) * 100));
        }
        
        this.wpmDisplay.textContent = wpm;
        this.accuracyDisplay.textContent = `${accuracy}%`;
        this.progressDisplay.textContent = `${progress}%`;
        this.progressBar.style.width = `${progress}%`;
      }

      endTest() {
        this.isActive = false;
        this.input.disabled = true;
        this.input.placeholder = "Test completed!";
        
        if (this.timerInterval) clearInterval(this.timerInterval);
        if (this.updateInterval) clearInterval(this.updateInterval);
        
        const elapsed = (new Date() - this.startTime) / 1000 / 60; // minutes
        const wpm = elapsed > 0 ? Math.round((this.correctChars / 5) / elapsed) : 0;
        const accuracy = this.totalChars > 0 ? Math.round((this.correctChars / this.totalChars) * 100) : 0;
        const wordsTyped = Math.floor(this.correctChars / 5);
        
        // Update progress tracking
        this.progressSystem.updateStats(wpm, accuracy, wordsTyped, this.errors);
        
        // Check for achievements
        const stats = this.progressSystem.getStats();
        const newAchievements = this.achievementSystem.checkAchievements(wpm, accuracy, stats.totalTests);
        
        // Show achievement notifications
        newAchievements.forEach((achievement, index) => {
          setTimeout(() => {
            this.achievementSystem.showAchievement(achievement);
          }, index * 1000);
        });
        
        // Update final results
        this.finalWPM.textContent = wpm;
        this.finalAccuracy.textContent = `${accuracy}%`;
        this.finalChars.textContent = this.totalChars;
        this.finalErrors.textContent = this.errors;
        
        // Update streak display
        this.updateStreakDisplay();
        
        // Show results with animation
        this.results.classList.add("show");
        
        // Re-enable start button
        this.startBtn.disabled = false;
        this.startBtn.textContent = "Start New Test";
        
        // Scroll to results
        this.results.scrollIntoView({ behavior: "smooth" });
      }

      showError(message, type = 'error') {
        this.errorMessage.textContent = message;
        this.errorMessage.className = `error-message show ${type}`;
        if (type === 'success') {
          this.errorMessage.style.background = 'rgba(0, 255, 136, 0.1)';
          this.errorMessage.style.borderColor = 'var(--success-color)';
          this.errorMessage.style.color = 'var(--success-color)';
        } else {
          this.errorMessage.style.background = 'rgba(255, 71, 87, 0.1)';
          this.errorMessage.style.borderColor = 'var(--error-color)';
          this.errorMessage.style.color = 'var(--error-color)';
        }
        setTimeout(() => this.hideError(), 3000);
      }

      hideError() {
        this.errorMessage.classList.remove("show");
      }

      // New feature methods
      updateStreakDisplay() {
        const stats = this.progressSystem.getStats();
        this.streakDisplay.textContent = stats.streak;
      }

      showCustomTextContainer() {
        this.customTextContainer.style.display = 'block';
        this.customTextInput.focus();
      }

      hideCustomTextContainer() {
        this.customTextContainer.style.display = 'none';
        this.customTextInput.value = '';
      }

      useCustomText() {
        const text = this.customTextInput.value.trim();
        if (text.length < 10) {
          this.showError('Please enter at least 10 characters for custom text practice.');
          return;
        }
        
        this.customText = text;
        this.modeSelect.value = 'custom';
        this.hideCustomTextContainer();
        this.startTest();
      }

      showLeaderboard() {
        this.leaderboardModal.classList.add('show');
        this.populateLeaderboard();
      }

      hideLeaderboard() {
        this.leaderboardModal.classList.remove('show');
      }

      showAchievements() {
        this.achievementsModal.classList.add('show');
        this.populateAchievements();
      }

      hideAchievements() {
        this.achievementsModal.classList.remove('show');
      }

      populateLeaderboard() {
        const stats = this.progressSystem.getStats();
        const history = stats.testHistory.slice(-10).reverse(); // Last 10 tests
        
        this.leaderboardContent.innerHTML = '';
        
        if (history.length === 0) {
          this.leaderboardContent.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">No tests completed yet. Start typing to see your scores!</p>';
          return;
        }

        history.forEach((test, index) => {
          const entry = document.createElement('div');
          entry.className = 'leaderboard-entry';
          entry.innerHTML = `
            <div class="leaderboard-rank">#${index + 1}</div>
            <div class="leaderboard-details">
              <div class="leaderboard-wpm">${test.wpm} WPM</div>
              <div class="leaderboard-date">${test.date} ‚Ä¢ ${test.accuracy}% accuracy</div>
            </div>
          `;
          this.leaderboardContent.appendChild(entry);
        });
      }

      populateAchievements() {
        this.achievementsContent.innerHTML = '';
        
        Object.values(this.achievementSystem.achievements).forEach(achievement => {
          const item = document.createElement('div');
          item.className = `achievement-item ${achievement.unlocked ? 'unlocked' : ''}`;
          
          const progress = Math.min(100, (achievement.progress / achievement.target) * 100);
          
          item.innerHTML = `
            <div class="achievement-badge">${achievement.icon}</div>
            <div class="achievement-info">
              <h4>${achievement.name}</h4>
              <p>${achievement.description}</p>
              ${!achievement.unlocked ? `
                <div class="achievement-progress">
                  <div class="achievement-progress-fill" style="width: ${progress}%"></div>
                </div>
              ` : ''}
            </div>
          `;
          
          this.achievementsContent.appendChild(item);
        });
      }

      createParticleEffect(x, y) {
        for (let i = 0; i < 5; i++) {
          const particle = document.createElement('div');
          particle.className = 'particle';
          particle.style.left = x + 'px';
          particle.style.top = y + 'px';
          particle.style.backgroundColor = `hsl(${Math.random() * 60 + 120}, 70%, 60%)`;
          particle.style.width = '4px';
          particle.style.height = '4px';
          
          document.body.appendChild(particle);
          
          setTimeout(() => {
            if (particle.parentNode) {
              particle.parentNode.removeChild(particle);
            }
          }, 1000);
        }
      }

      addScreenShake() {
        document.body.classList.add('screen-shake');
        setTimeout(() => {
          document.body.classList.remove('screen-shake');
        }, 300);
      }

    }

    // Initialize the game when page loads
    document.addEventListener("DOMContentLoaded", () => {
      const game = new TypingGame();
    });
  </script>
</body>
</html>
